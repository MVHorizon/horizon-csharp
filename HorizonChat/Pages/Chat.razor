@page "/chat"
@using System.Net.WebSockets
@using System.Text
@using System.Text.Json
@using HorizonChat.Services
@using Microsoft.JSInterop
@inject NavigationManager NavigationManager
@inject UserStateService UserState
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>Chat Room - HorizonChat</PageTitle>

<div class="chat-container">
    <div class="chat-header">
        <h2>üéØ HorizonChat</h2>
        <div class="user-info">
            <div class="user-details">
                <span class="username-badge">@UserState.Username</span>
                <div class="status-selector">
                    <select class="form-select form-select-sm status-dropdown" value="@selectedStatus" @onchange="OnStatusChange">
                        @foreach (var status in UserState.AvailableStatuses)
                        {
                            <option value="@status">@status</option>
                        }
                        <option value="custom">Custom...</option>
                    </select>
                    @if (selectedStatus == "custom")
                    {
                        <input 
                            type="text" 
                            class="form-control form-control-sm custom-status-input"
                            placeholder="Enter custom status (max 30 chars)"
                            maxlength="30"
                            @bind="customStatus"
                            @bind:event="oninput"
                            @onblur="ApplyCustomStatus" />
                    }
                </div>
                <span class="status-badge">@UserState.Status</span>
            </div>
            <button class="btn btn-sm btn-outline-secondary" @onclick="LeaveChat">Leave</button>
        </div>
    </div>

    <div class="messages-container" @ref="messagesContainer" id="messagesContainer">
        @if (messages.Count == 0)
        {
            <div class="no-messages">
                <p>No messages yet. Start the conversation! üí¨</p>
            </div>
        }
        else
        {
            @foreach (var message in messages)
            {
                <div class="message @(message.Username == UserState.Username ? "message-own" : "message-other")">
                    <div class="message-header">
                        <span class="message-username">
                            @message.Username
                            @if (!string.IsNullOrEmpty(message.Status))
                            {
                                <span class="message-status">(@message.Status)</span>
                            }
                        </span>
                        <span class="message-timestamp">@message.Timestamp.ToString("HH:mm")</span>
                    </div>
                    <div class="message-content">
                        @message.Text
                    </div>
                </div>
            }
        }
    </div>

    <div class="message-input-container">
        @if (!string.IsNullOrWhiteSpace(errorMessage))
        {
            <div class="alert alert-danger alert-sm">@errorMessage</div>
        }
        <div class="input-group">
            <input 
                type="text" 
                class="form-control message-input" 
                placeholder="Type your message..."
                maxlength="1000"
                @bind="currentMessage"
                @bind:event="oninput"
                @onkeypress="HandleKeyPress"
                disabled="@(!isConnected)" />
            <button 
                class="btn btn-primary send-button" 
                @onclick="SendMessage"
                disabled="@(!CanSendMessage)">
                <span class="oi oi-share"></span> Send
            </button>
        </div>
        <div class="connection-status">
            @if (isConnected)
            {
                <span class="status-connected">‚óè Connected</span>
            }
            else
            {
                <span class="status-disconnected">‚óè Disconnected</span>
            }
        </div>
    </div>
</div>

@code {
    private ClientWebSocket? webSocket;
    private CancellationTokenSource? cancellationTokenSource;
    private List<ChatMessage> messages = new();
    private string currentMessage = string.Empty;
    private string errorMessage = string.Empty;
    private bool isConnected = false;
    private ElementReference messagesContainer;
    private string selectedStatus = "Available";
    private string customStatus = string.Empty;

    private bool CanSendMessage => 
        isConnected && 
        !string.IsNullOrWhiteSpace(currentMessage) && 
        currentMessage.Trim().Length > 0;

    protected override async Task OnInitializedAsync()
    {
        // Check if user has selected a username
        if (!UserState.IsUserAuthenticated)
        {
            NavigationManager.NavigateTo("/");
            return;
        }

        selectedStatus = UserState.Status;
        await ConnectToWebSocket();
    }

    private async Task OnStatusChange(ChangeEventArgs e)
    {
        var newStatus = e.Value?.ToString() ?? "Available";
        if (newStatus != "custom")
        {
            selectedStatus = newStatus;
            await UpdateStatus();
        }
        else
        {
            selectedStatus = "custom";
        }
    }

    private async Task UpdateStatus()
    {
        if (selectedStatus != "custom")
        {
            UserState.SetStatus(selectedStatus);
            await BroadcastStatusUpdate();
        }
    }

    private async Task ApplyCustomStatus()
    {
        if (!string.IsNullOrWhiteSpace(customStatus))
        {
            try
            {
                UserState.SetStatus(customStatus.Trim());
                selectedStatus = customStatus.Trim();
                await BroadcastStatusUpdate();
            }
            catch (ArgumentException ex)
            {
                errorMessage = ex.Message;
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to set status: {ex.Message}";
            }
        }
    }

    private async Task BroadcastStatusUpdate()
    {
        if (webSocket?.State != WebSocketState.Open)
            return;

        try
        {
            var statusUpdate = new
            {
                Type = "status",
                Username = UserState.Username,
                Status = UserState.Status,
                Timestamp = DateTime.Now
            };

            var messageJson = JsonSerializer.Serialize(statusUpdate);
            var messageBytes = Encoding.UTF8.GetBytes(messageJson);

            await webSocket.SendAsync(
                new ArraySegment<byte>(messageBytes),
                WebSocketMessageType.Text,
                true,
                CancellationToken.None);
        }
        catch
        {
            // Ignore errors in status broadcast
        }
    }

    private async Task ConnectToWebSocket()
    {
        try
        {
            webSocket = new ClientWebSocket();
            cancellationTokenSource = new CancellationTokenSource();

            var uri = new Uri($"{NavigationManager.BaseUri.Replace("http", "ws")}ws");
            await webSocket.ConnectAsync(uri, cancellationTokenSource.Token);
            
            isConnected = true;
            errorMessage = string.Empty;
            StateHasChanged();

            // Start listening for messages
            _ = Task.Run(() => ReceiveMessages(cancellationTokenSource.Token));
        }
        catch (Exception ex)
        {
            errorMessage = $"Connection failed: {ex.Message}";
            isConnected = false;
            StateHasChanged();
        }
    }

    private async Task ReceiveMessages(CancellationToken cancellationToken)
    {
        var buffer = new byte[1024 * 4];
        
        try
        {
            while (webSocket?.State == WebSocketState.Open && !cancellationToken.IsCancellationRequested)
            {
                var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), cancellationToken);
                
                if (result.MessageType == WebSocketMessageType.Text)
                {
                    var messageJson = Encoding.UTF8.GetString(buffer, 0, result.Count);
                    
                    try
                    {
                        var message = JsonSerializer.Deserialize<ChatMessage>(messageJson, new JsonSerializerOptions
                        {
                            PropertyNameCaseInsensitive = true
                        });

                        if (message != null)
                        {
                            await InvokeAsync(() =>
                            {
                                messages.Add(message);
                                StateHasChanged();
                                ScrollToBottom();
                            });
                        }
                    }
                    catch
                    {
                        // If deserialization fails, treat as plain text echo
                        var echoMessage = new ChatMessage
                        {
                            Username = "System",
                            Text = messageJson,
                            Timestamp = DateTime.Now
                        };
                        
                        await InvokeAsync(() =>
                        {
                            messages.Add(echoMessage);
                            StateHasChanged();
                            ScrollToBottom();
                        });
                    }
                }
                else if (result.MessageType == WebSocketMessageType.Close)
                {
                    await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
                    isConnected = false;
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        catch (Exception ex)
        {
            if (!cancellationToken.IsCancellationRequested)
            {
                errorMessage = $"Connection lost: {ex.Message}";
                isConnected = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task SendMessage()
    {
        if (!CanSendMessage || webSocket?.State != WebSocketState.Open)
            return;

        try
        {
            // Validate message length
            var trimmedMessage = currentMessage.Trim();
            if (trimmedMessage.Length > 1000)
            {
                errorMessage = "Message is too long. Maximum 1000 characters allowed.";
                return;
            }

            var message = new ChatMessage
            {
                Username = UserState.Username,
                Text = trimmedMessage,
                Status = UserState.Status,
                Timestamp = DateTime.Now
            };

            var messageJson = JsonSerializer.Serialize(message);
            var messageBytes = Encoding.UTF8.GetBytes(messageJson);

            await webSocket.SendAsync(
                new ArraySegment<byte>(messageBytes),
                WebSocketMessageType.Text,
                true,
                CancellationToken.None);

            currentMessage = string.Empty;
            errorMessage = string.Empty;
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to send message: {ex.Message}";
        }
    }

    private void HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && CanSendMessage)
        {
            _ = SendMessage();
        }
    }

    private void LeaveChat()
    {
        NavigationManager.NavigateTo("/");
    }

    private async void ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", "messagesContainer");
        }
        catch
        {
            // JS interop may fail during initial render or disposal
        }
    }

    public async ValueTask DisposeAsync()
    {
        cancellationTokenSource?.Cancel();
        
        if (webSocket?.State == WebSocketState.Open)
        {
            await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Leaving chat", CancellationToken.None);
        }
        
        webSocket?.Dispose();
        cancellationTokenSource?.Dispose();
    }

    private class ChatMessage
    {
        public string Username { get; set; } = string.Empty;
        public string Text { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
    }
}
